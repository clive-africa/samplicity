"""
market.

A module containing the Market class.
This class is used to calculate the market risk charges as
part of the non-life SCR.

@author: chogarth


"""

# These are the generic packages that we use in the class
import pandas as pd
import math
import numpy as np
from typing import Union

# A package for the display of dataframes in the console.
# from tabulate import tabulate
import logging


from ..helper import combins_df_col, log_decorator, allocation_matrix

# This is a custom package that we use in the market risk calcaultions.
from . import bond as bv
from .aggregate import f_aggregate_market

# We store our type 1 credit risk calcualtion here
from .credit import f_credit_type_1, f_impairment, f_u_matrix, f_v_vector
from .conc import f_concentration_risk

logger = logging.getLogger(__name__)


class Market:
    """
    Calculate the SAM market risk for a non-life insurer.

    Limitations
    -----------
    - Need to resolve the day count issue.
      Currently the fucntion uses ACTUAL/ACTUAL.
      In reality it might be better to use ACTUAL/365
    - No allowance is made for the assest shocks.
      This would need to be a seperate data import, not very complex.'
    - We make no accurate calcaultion of the dirty market price.
    - In the calcualtion we disocunt all cashflows at the risk-free rate.
      In reality there is a spread on almsot all assets. We could add
      this but that would require a newton-raphson approximation.


    Attributes
    ----------
    scr : SCR class
        a reference to the main SCR class with all the input data required.
    output : dictionary
       a dictionary of all output values that are generated by the SCR class.
    doc_data : dictionary
        a df documenting the data that can be extracted from the Market class.


    Methods
    -------
    __init__:
        Create the dictionaries that will be used by the class
    f_credit_type_1:
        Calcualte type 1 credit risk charges and default impairment.
    f_concentration_risk:
        Calculate concentration risk charges.
    f_aggregate_charges:
        Aggregate the various market risk charges.
    f_calculate_market_risk:
        Calculate the various market risk charges, with a loop.
    f_calculate_impairment:
        Calculate the impairment charges for reinsurance.
    """

    @log_decorator
    def __init__(self, sam_scr, class_name="market_risk", calculate=False):
        """Construct all the initial attributes for the MARKET object.

        This mainly consists of the various metadata required for the shocks

        """
        # logger.debug("Function start")

        self.scr = sam_scr
        """ A reference to the main SCR class."""

        self.output = {}
        """Store all of the outputs from the calculation."""

        asset_by_shock = self.scr.f_data("data", "data", "asset_shocks")
        self.output["asset_shocks"] = asset_by_shock.groupby("shock")[
            "asset_type"
        ].apply(list)

        # In this process we import copies of our data, the underlying data
        # is never edited.
        self.output["asset_data"] = self.scr.f_data("data", "data", "asset_data")
        self.output["counterparty"] = self.scr.f_data("data", "data", "counterparty")

        # Now we join the counterparty data to add the CQS fields
        # Before we do that we populate a few fields
        # Where the asset cqs is provided we must populate the
        # lgd_adjsutment with the base - 1.
        # We will late make sure we use the counterparty CQS.
        asset_cqs = self.output["asset_data"]["asset_cqs"].isna()
        self.output["asset_data"].loc[asset_cqs, "lgd_adj"] = "unsecured"

        self.output["counterparty"].fillna(
            {"counterparty_group": self.output["counterparty"]["id"]}, inplace=True
        )

        counterparty = self.output["counterparty"][
            ["id", "counterparty_cqs", "counterparty_group", "counterparty_collateral"]
        ].copy(deep=True)
        counterparty.rename(columns={"id": "counterparty_id"}, inplace=True)

        asset_data = self.output["asset_data"]
        asset_data = asset_data.merge(counterparty, how="left", on="counterparty_id")
        asset_data["used_cqs"] = asset_data["asset_cqs"]
        asset_data[["collateral", "counterparty_collateral", "market_value"]] = (
            asset_data[
                ["collateral", "counterparty_collateral", "market_value"]
            ].astype(float)
        )
        asset_data.fillna(
            {
                "used_cqs": asset_data["counterparty_cqs"],
                "collateral": 0,
                "counterparty_collateral": 0,
                "market_value": 0,
            },
            inplace=True,
        )

        # We now deal with the difference between the concentration risk
        # and credit risk calcualtion
        asset_data["conc_cqs"] = asset_data["used_cqs"]
        asset_data["conc_cqs"] = asset_data["conc_cqs"].apply(
            lambda x: np.floor(min(max(x, 1), 19))
        )
        asset_data["conc_cqs"] = asset_data["conc_cqs"].fillna(19)

        asset_data["used_cqs"] = asset_data["used_cqs"].apply(
            lambda x: np.floor(min(max(x, 1), 18))
        )
        asset_data["used_cqs"] = asset_data["used_cqs"].fillna(18)

        self.class_data = pd.DataFrame(None)
        """ A df to store the data that can be extracted from the class. """

        """
            START: WARNING >>> WARNING >>> WARNING    
        
            Need to debate this field, should this be the default or the 
            most onerous.
            
        """

        asset_data.fillna({"lgd_adj": "unsecured"}, inplace=True)
        sprd_adj = self.scr.f_data("data", "metadata", "spread_lgd_adj")[
            ["lgd_adj", "lgd"]
        ]
        sprd_adj.rename(columns={"lgd_adj": "lgd_adjustment"}, inplace=True)
        asset_data = asset_data.merge(
            sprd_adj, how="left", left_on="lgd_adj", right_index=True
        )

        self.output["asset_data"] = asset_data
        """
            
            Need to debate this field, should this be teh default or 
            the most onerous
            
            END: WARNING >>> WARNING >>> WARNING
        """

        # We store thsi at a global variable because we use it later
        # for our outputs.
        self.output["shock_fields"] = [
            "calc_mv",
            "mv_up",
            "mv_down",
            "duration",
            "ytm",
            "conc_type",
            "conc_ind",
            "credit_type_1_ind",
            "int_curve_nominal_up",
            "int_curve_nominal_down",
            "int_curve_real_up",
            "int_curve_real_down",
            "int_volatility",
            "equity_price_global",
            "equity_price_sa",
            "equity_price_infrastructure",
            "equity_price_other",
            "equity_volatility",
            "property",
            "currency_up",
            "currency_down",
            "spread_interest",
            "spread_credit_up",
            "spread_credit_down",
            "credit_type_1",
            "credit_type_2",
            "credit_type_3",
            "concentration_risk",
            "illiquidity",
            "total_market",
        ]
        self.output["asset_data"][self.output["shock_fields"]] = 0.0
        self.output["asset_data"]["conc_type"] = self.output["asset_data"][
            "conc_type"
        ].astype(object)

        self.output["div_field"] = self.scr.f_data(
            "data", "data", "diversification_level"
        ).iloc[0]
        calc_level = self.scr.f_data("data", "data", "calculation_level").iloc[0]

        # lst = combins_df_col(
        #    self.output["asset_data"], self.output["div_field"], calc_level
        # )
        # df_allocation = pd.DataFrame(lst).apply(pd.Series.value_counts, 1).fillna(0)
        # df_allocation.index = lst
        df_allocation = allocation_matrix(
            self.output["asset_data"], self.output["div_field"], calc_level
        )
        self.output["df_allocation"] = df_allocation

        # Allow for the allocation of the investment portfolio
        # TODO: Need to get the investment portfolio
        # TODO: Create an identify matrxi
        # TODO: Add the asset allocation to the identity matrix where the column is the investment portfolio

        shock = self.scr.f_data("data", "metadata", "equity_price")
        sa_adjustment = self.scr.f_data("data", "pa_data", "symmetric_adjustment")
        sa_adjustment["infrastructure"] = sa_adjustment["sa"] * 0.77
        equity_shock = shock["equity_price"] + sa_adjustment.iloc[0, :]
        equity_shock[equity_shock < 0.1] = 0.1
        self.output["equity_shock"] = equity_shock

        # These terms are used by the bond valuation class
        val_date = self.scr.f_data("data", "data", "valuation_date").iloc[0].date()

        # We need to calculate the interest rate rate for the various
        # interest rate instruments. We initialise the bond class here,
        # we will only use it later when we calcualte the market risk.
        self.sam_market_bond = bv.BOND_VAL(
            val_date,
            self.scr.f_data("data", "pa_data", "real"),
            self.scr.f_data("data", "pa_data", "nominal"),
            self.scr.f_data("data", "metadata", "shock_interest_rate"),
        )

        # We get our U matrix and populate it here
        # The actual calculations are done in the crediit module
        self.output["u"] = f_u_matrix(self)
        self.output["v"] = f_v_vector(self)

        self.scr.classes[class_name] = self
        if calculate:
            self.f_market_risk()
            self.f_calc_impairment()

    @log_decorator
    def f_market_risk(self):
        """Calculate the market risk charges for each asset.

        The current process makes used of a nexted loop.
        It could be sped up using variosu vector operations.
        However, the code should really run quite fast even with a
        lot of assets.
        To keep readability, a simply nested loop has been used.
        If we run into speed issues this approach will be re-visited.
        The amin work is going to happen when we start to allocate assets
        to the different portfolios.

        """
        # logger.debug("Function start")

        shock_list = list(np.unique(self.output["asset_shocks"].index))
        # Need to put in a calculation around the asset & counterparty cqs

        for shock in shock_list:
            # A list of assets we need to shcok
            types_to_shock = self.output["asset_shocks"][shock]
            incl = self.output["asset_data"]["asset_type"].isin(types_to_shock)
            # Shoteting the reference that we need to use
            asset_data = self.output["asset_data"]

            # print(f"Shock: {shock}, Number: {sum(incl)}")
            # logger.debug(f"Shock: {shock}, Number: {sum(incl)}")
            # Calculate the various equity shocks
            if shock in (
                "equity_global",
                "equity_sa",
                "equity_infrastructure",
                "equity_other",
            ):
                col_value = shock.replace("equity_", "")
                mod_shock = shock.replace("equity_", "equity_price_")
                asset_data.loc[incl, mod_shock] = (
                    asset_data.loc[incl, "market_value"]
                    * self.output["equity_shock"][col_value]
                )

            elif shock == "equity_volatility":
                # Thie has to be input manually
                asset_data.loc[incl, "equity_volatility"] = asset_data.loc[
                    incl, "equity_volatility_shock"
                ]

            elif shock == "property":
                asset_data.loc[incl, "property"] = (
                    asset_data.loc[incl, "market_value"] * 0.25
                )

            elif shock == "currency":
                asset_data.loc[incl, "currency_up"] = (
                    asset_data.loc[incl, "market_value"] * 0.5
                )
                asset_data.loc[incl, "currency_down"] = (
                    -1 * asset_data.loc[incl, "market_value"] * 0.3
                )

            elif shock == "spread_credit":
                asset_data.loc[incl, ["spread_credit_up", "spread_credit_up_shock"]] = (
                    asset_data.loc[incl, ["spread_credit_up", "spread_credit_up_shock"]]
                )

            elif shock == "concentration":
                asset_data.loc[incl, "conc_include"] = 3
                asset_data.loc[incl, "conc_type"] = "other"

            elif shock == "concentration_bank":
                asset_data.loc[incl, "conc_include"] = 2
                asset_data.loc[incl, "conc_type"] = "bank"

            elif shock == "concentration_government":
                asset_data.loc[incl, "conc_include"] = 1
                asset_data.loc[incl, "conc_type"] = "government"

            elif shock == "default_type_1":
                asset_data.loc[incl, "credit_type_1_ind"] = 1
                self.output["credit_type_1_charge"] = f_credit_type_1(self)

            elif shock == "default_type_2":
                asset_data.loc[incl, "credit_type_2"] = (
                    asset_data.loc[incl, "market_value"] * 0.15
                )

            elif shock == "default_type_2_overdue":
                asset_data.loc[incl, "credit_type_2"] = (
                    asset_data.loc[incl, "market_value"] * 0.9
                )

            # Need to chekc these
            elif shock in ("default_type_3"):
                cqs = asset_data.loc[incl, "used_cqs"]
                factor = self.scr.f_data(
                    "data", "metadata", "credit_type_3_factor"
                ).loc[cqs, "factor"]
                asset_data.loc[incl, "credit_type_3"] = asset_data.loc[
                    incl, "market_value"
                ] * np.array(factor)

            elif shock in ("spread_interest", "spread_interest_infastructure"):
                asset_data.loc[incl, "spread_interest"] = self.f_spread_interest(
                    shock, asset_data.loc[incl, :]
                )

            elif shock == "interest_rate":
                # We have the bond class for our valuation
                # it is already defined
                # We loop thorugh all of our assets to get the shocks, this
                # has tobe done with a loop for now. :(
                # Could get some speed with the vectorize function in numpy
                # but a lof of the ground work is done in p
                # Could loop to replace this with bond-pricing package.

                shock_assets = asset_data.loc[incl, :]
                for i in range(len(shock_assets)):
                    (
                        calc_mv,
                        mv_up,
                        mv_down,
                        duration,
                        ytm,
                    ) = self.sam_market_bond.f_calculate(asset_data.iloc[i, :])
                    asset_data.loc[
                        asset_data.index[i],
                        [
                            "calc_mv",
                            "mv_up",
                            "mv_down",
                            "duration",
                            "ytm",
                            "int_curve_nominal_up",
                            "int_curve_nominal_down",
                        ],
                    ] = [
                        calc_mv,
                        mv_up,
                        mv_down,
                        duration,
                        ytm,
                        mv_up - calc_mv,
                        mv_down - calc_mv,
                    ]

        # We ahve been able to run the type 1 default calculation but now we
        # need to run concentration riks
        # Concemtration risk has multiple shock we need to worry about
        # Hence the treatment is slightly differenet.

        self.output["concentration_risk_charge"] = f_concentration_risk(self)

        # Perform the allocation across the different portfolios
        summary_data = asset_data[
            self.output["shock_fields"] + [self.output["div_field"]]
        ]
        summary_data = summary_data.drop(labels="conc_type", axis="columns")

        summary_data = summary_data.groupby(
            by=self.output["div_field"], dropna=False
        ).sum()
        # summary_data.index=summary_data.index.fillna('None')
        # test=summary_data.index.fillna('None')

        # We need to edit this code to allow for an allocation us assets from the common investmetn portfolio
        summary_data = self.output["df_allocation"][summary_data.index].dot(
            summary_data
        )

        # Calculate concentration risk and type 1 credit risk seperately.
        # The calculations and aggregation happen seperately
        # We populate the results in the 'summ_data' dataframe.
        summary_data["credit_type_1"] = self.output["credit_type_1_charge"].loc[
            summary_data.index, :
        ]
        summary_data["concentration"] = self.output["concentration_risk_charge"].loc[
            summary_data.index, "result"
        ]

        self.output["summary_data"] = summary_data

        # Now comes the part where all the aggeregation should occur
        self.f_aggregate_charges()

        return summary_data

    def f_spread_interest(self, shock, asset_data):
        """Calculate the spread interest rate shock."""
        # Create our infastructure adjustments
        if shock == "spread_interest_infastructure":
            adj = 0.7
        else:
            adj = 1.0

        # NOw we need to loop through the different CQS values
        # Could avoid this with a 2D interpolation but the numpy
        # implementation has been discontinued
        # We limit the CQS because we should be able to skip a lot
        # of values
        # Unlikley to have counterparties in the first 10 entires
        unique_cqs = np.unique(asset_data.loc[:, "used_cqs"])
        for cqs in unique_cqs:
            include_calc = cqs == asset_data["used_cqs"]
            charge = np.interp(
                asset_data.loc[:, "mod_duration"],
                self.scr.f_data("data", "metadata", "spread_risk_factors").columns,
                self.scr.f_data("data", "metadata", "spread_risk_factors").loc[cqs, :],
            )

        res = (
            asset_data.loc[:, "market_value"]
            * charge
            * adj
            * asset_data.loc[:, "lgd_adjustment"]
        )
        return res

    def f_aggregate_charges(self):
        """Aggregate the different market risk charges."""
        # logger.debug("Function start")

        res = f_aggregate_market(self)
        self.output["summary_data"] = res

    @log_decorator
    def f_calc_impairment(self):
        """Calculate the impairment charges for reinsurance recoveries."""
        # logger.debug("Function start")

        self.output["impairment_charge"] = f_impairment(self)

    def f_data(self, data: str = "", sub_data: str = "") -> Union[pd.DataFrame, None]:
        """Output values that are stored with the Market class."""
        # logger.debug("Function start")

        try:
            # Just some cleaning of our inputs to ensure no errors occur
            data = data.lower().strip()
            if sub_data != None:
                sub_data = sub_data.lower().strip()

            if sub_data == "":
                df = self.output[data]
            elif data in ("summary_data"):
                df = self.output[data]
            elif data == "market_shocks":
                cols = self.output["summary_data"].columns.values
                df = pd.DataFrame(cols, columns=["columns"], index=cols)
            elif (data == "impairment_charge") & (sub_data == "all"):
                df = self.__f_impair_data()
                # print("function " + type(df).__name__)
            else:
                df = self.output[data]
        except:
            logger.critical(f"Error: {data} - {sub_data}")
            raise ValueError
        else:
            if not df is None:
                df = df.copy(deep=True)
            # print("market " + type(df).__name__)
            return df

    def __f_impair_data(self) -> pd.DataFrame:
        """Retrieve all of the impairment changes."""
        # logger.debug("Function start")

        # Get a list of all the dataframe
        df_list = [
            df.rename(columns={"result": k})
            for k, df in self.output["impairment_charge"].items()
            if df is not None
        ]
        # Will use these to populate balnk columns
        df_blank = [
            k for k, df in self.output["impairment_charge"].items() if df is None
        ]
        # Thsi step won't group our data
        res = pd.concat(df_list)
        # Remove all of the NA figures
        res.fillna(0, inplace=True)
        res = res.groupby("index").sum()
        # Populate our blank columns
        res[df_blank] = 0
        return res
