# These are the different packages that we require to run our code
import pandas as pd
#import numpy as np
import venv
from typing import Optional, Union, Literal, List
import pickle
import os
import subprocess
import sys
from tqdm import tqdm

# A package for the display of dataframes in the console.
# from tabulate import tabulate

#import logging

from . import aggregation as agg

# A custom module with some generic helper functions
# Tehse are used across the different
from .. import helper as hf
from . import info

#logger = logging.getLogger(__name__)

# These contain the different classes used in the SAM SCR calculation
# Theses are helper classes for the main SCR class.
from ..data.data import Data
from ..prem_res import PremRes
from ..nat_cat import NatCat
from ..factor_cat import FactorCat
from ..man_made import ManMade
from ..non_prop import NonProp

from ..op_risk import OpRisk
from ..market.market import Market
from ..reinsurance.reinsurance import Reinsurance

from .diversification import shapely_calc

from ..helper import log_decorator
import datetime
#import os
#import subprocess
import traceback


class SCR:
    """
    SCR is the main class of the samplicity package.

    The class represents and calculates the SAM SCR for a non-life insurer.

    This class serves as the main coordinator for SCR calculations, managing various
    risk modules and aggregating results to produce the final SCR figure.

    At a high level these are the variable acessible from the class.

    :ivar classes: A dictionary of all the supporting classes used by the main SCR class.
    :vartype classes: dict
    :ivar output: A dictionary of all output values generated by the SCR class.
    :vartype output: dict
    :ivar output_runtimes: A list of dictionaries containing runtime information for various sections.
    :vartype output_runtimes: list
    :ivar output_errors: A list of dictionaries containing error and warning information.
    :vartype output_errors: list
    :ivar calculation_steps: A list of tuples containing calculation step names and corresponding methods.
    :vartype calculation_steps: list

    .. note::
        This class follows specific naming conventions:

        - output_*: Outputs as a result of calculations within the class.
        - f_*: Functions that are used in the calculation.
        - _f_*: Functions that are used internally and not directly called by the user.

    .. warning::
        - The class does not currently support lapse risk calculations.
        - Life insurance risk is not included in the SCR calculation.
        - Man-made catastrophe perils must be populated manually.
        - The diversification calculation uses an approximation for man-made catastrophe risk.
        - LACDT (Loss-Absorbing Capacity of Deferred Taxes) allowance may be inaccurate for certain combinations of products.
        - Market risk calculations do not account for the risk margin on assets.
        - The class assumes a non-life insurer and may not be suitable for life or composite insurers.
        - Liability shocks are not currently incorporated into the calculations.
    """

    @log_decorator
    def __init__(self):
        """Initialize the SCR class."""
        # Store classes in a dictionary to simplify the data storage.
        # A little cleaner than storing each separate class in the SCR class.
        # There are a large number of classes to support the SCR class.
        self.classes: dict = {}
        """ Stores the classes that support the SCR class and calculation. """

        # Stores the results from the SCR class.
        # Still need to workout how best to output the data
        self.output: dict = {}
        """ All the outputs for the class with the various results. """

        # Store the run times of the different sections.
        # This can help if ever a speed isse
        self.output_runtimes: list = []
        """ Stores the runtimes of the different sections of code.
            Used to help with code performance. """

        self.output_errors: list = []
        """ Stores any errors or warnings that result at runtime. """

        self.calculation_steps: list = [
            ("Diversification calculations", "diversification"),
            ("Premium and Reserve Risk", "prem_res"),
            ("Natural Catastrophe Risk", "nat_cat"),
            ("Factor Catastrophe Risk", "factor_cat"),
            ("Man-Made Catastrophe Risk", "man_made_cat"),
            ("Non-Proportional Reinsurance Risk", "non_prop_cat"),
            ("Reinsurance Risk", "reinsurance"),
            ("Operational Risk", "op_risk"),
            ("Market Risk", "market_risk"),
            ("Aggregation", "aggregation"),
        ]
        """ Contains all the default calculation steps to be run. """

    def create_supporting(
        self,
        class_type: Literal[
            "diversification",
            "prem_res",
            "nat_cat",
            "factor_cat",
            "man_made_cat",
            "non_prop_cat",
            "reinsurance",
            "op_risk",
            "market_risk",
            "aggregation",
        ],
        class_name: str = "",
        calculate: bool = True,
    ) -> Union[
        PremRes, NatCat, FactorCat, ManMade, NonProp, Reinsurance, OpRisk, Market, None
    ]:
        """
        Create and initialize a supporting risk module class.

        This function acts as a factory method to create various risk module objects
        used in the SCR calculation. It allows for flexible instantiation of different
        risk modules based on the provided class type.

        :param class_type:  The type of risk module to create. Must be one of: ["diversification", "prem_res", "nat_cat", "factor_cat", "man_made_cat", "non_prop_cat", "reinsurance", "op_risk", "market_risk", or "aggregation"].
        :type class_type:   str
        :param class_name: The name to assign to the created class instance. If not provided,
                        it defaults to the value of `class_type`.
        :type class_name: str, optional
        :return: An instance of the specified risk module class.
        :rtype: Union[PremRes, NatCat, FactorCat, ManMade, NonProp, Reinsurance, OpRisk, Market]
        :raises ValueError: If an unsupported class type is provided.

        :Example:

        >>> sam_scr = SCR()
        >>> prem_res_module = sam_scr.create_supporting("prem_res")
        >>> market_risk_module = sam_scr.create_supporting("market_risk", "custom_market")

        .. note::
        By default, all created instances are initialized with `calculate=True`, meaning
        their respective calculation methods will be called upon creation.

        .. warning::
        Ensure that the necessary data and configurations are set up in the SCR
        instance before calling this method, as the created modules may immediately
        start their calculations.
        """
        # We will allow for blank class names
        if class_name == "":
            class_name = class_type

        # Return the class from a function - helps with error handling
        if class_type == "diversification":
            self.f_diversification_calcs()
        elif class_type == "prem_res":
            return PremRes(self, class_name, calculate)
        elif class_type == "nat_cat":
            return NatCat(self, class_name, calculate)
        elif class_type == "factor_cat":
            return FactorCat(self, class_name, calculate)
        elif class_type == "man_made_cat":
            return ManMade(self, class_name, calculate)
        elif class_type == "non_prop_cat":
            return NonProp(self, class_name, calculate)
        elif class_type == "reinsurance":
            return Reinsurance(self, class_name, calculate)
        elif class_type == "op_risk":
            return OpRisk(self, class_name, calculate)
        elif class_type == "market_risk":
            return Market(self, class_name, calculate)
        elif class_type == "aggregation":
            self.f_aggregation()
        else:
            raise ValueError(f"Unsupported class type: {class_type}")

    def handle_calculation_error(
        self, step_name: str, error: Exception, halt_on_error: bool = True
    ) -> None:
        """
        Handle errors that occur during calculation steps, with an option to halt execution.

        This method processes errors that occur during the SCR calculation steps.
        It logs the error details, adds them to the `output_errors` list, and
        optionally halts the execution by re-raising the exception.

        :param step_name: The name of the calculation step where the error occurred.
        :type step_name: str
        :param error: The exception that was raised during the calculation step.
        :type error: Exception
        :param halt_on_error: If True, re-raises the exception to halt execution. Defaults to False.
        :type halt_on_error: bool, optional
        :return: None
        :rtype: None
        :raises Exception: Re-raises the original exception if halt_on_error is True.

        :Example:

        >>> try:
        ...     result = perform_calculation_step()
        ... except Exception as e:
        ...     self.handle_calculation_error("Market Risk Calculation", e, halt_on_error=True)

        .. note::
        When halt_on_error is False, this method collects error information
        for later processing or reporting without interrupting the calculation flow.

        .. warning::
        Setting halt_on_error to True will immediately stop the calculation process.
        Use this option judiciously, typically for critical errors that invalidate
        the entire calculation.

        The error details captured include:

        - Error type (always "error" for this method)
        - Step name where the error occurred
        - Error type (class name of the exception)
        - Error message
        - Full traceback of the error

        These details are stored as a dictionary in the `output_errors` list.
        """
        error_details = {
            "type": "error",
            "step": step_name,
            "error_type": type(error).__name__,
            "error_message": str(error),
            "traceback": traceback.format_exc(),
        }

        # Add to output_errors list
        self.output_errors.append(error_details)

        if halt_on_error:
            raise Exception(
                f"Calculation halted due to error in {step_name}: {error}"
            ) from error

    def handle_warning(self, step_name: str, warning_message: str, warning_detail: str):
        """
        Handle errors that occur during calculation steps. It logs the error details, adds them to the `output_errors` list.

        :param step_name: The name of the calculation step where the error occurred.
        :type step_name: str
        :param warning_message: A high-level warning message.
        :type warning_message: str
        :param warning_detail: Detail of the warning generated.
        :type warning_detail: str
        """
        warning_details = {
            "type": "warning",
            "step": step_name,
            "error_type": "",
            "error_message": warning_message,
            "traceback": warning_detail,
        }

        self.output_errors.append(warning_details)

    @log_decorator
    def f_calculate(
        self,
        steps_to_run: Optional[
            List[
                Literal[
                    "Diversification calculations",
                    "diversification",
                    "Premium and Reserve Risk",
                    "prem_res",
                    "Natural Catastrophe Risk",
                    "nat_cat",
                    "Factor Catastrophe Risk",
                    "factor_cat",
                    "Man-Made Catastrophe Risk",
                    "man_made_cat",
                    "Non-Proportional Reinsurance Risk",
                    "non_prop_cat",
                    "Reinsurance Risk",
                    "reinsurance",
                    "Operational Risk",
                    "op_risk",
                    "Market Risk",
                    "market_risk",
                    "Aggregation",
                    "aggregation",
                ]
            ]
        ] = None,
    ):
        """
        Perform the various calculation steps as required by the SCR class.

        This will call the diversification and aggregate from the SCR class
        as well as all of the supporting calculation classes PremRes, NatCat,
        FactorCat, ManMade, NonProp, Reinsurance, OpRisk, Market.

        :param steps_to_run: List of calculation steps to run. If None, all steps are run.
                             Allowed values are (full names or short names):
                             - "Diversification calculations" or "diversification"
                             - "Premium and Reserve Risk" or "prem_res"
                             - "Natural Catastrophe Risk" or "nat_cat"
                             - "Factor Catastrophe Risk" or "factor_cat"
                             - "Man-Made Catastrophe Risk" or "man_made_cat"
                             - "Non-Proportional Reinsurance Risk" or "non_prop_cat"
                             - "Reinsurance Risk" or "reinsurance"
                             - "Operational Risk" or "op_risk"
                             - "Market Risk" or "market_risk"
                             - "Aggregation" or "aggregation"
        :type steps_to_run: List[str] or None, optional

        :Example:

        >>> # The data import stesp are not shown here.
        >>> sam_scr = SCR()
        >>> # Perform all calculation steps.
        >>> sam_scr.f_calculate()
        >>> # Perform 3 of the calculation steps.
        >>> sam_scr.f_calculate(['diversification', 'prem_res', 'Natural Catastrophe Risk'])

        """
        # Allow for the user to select calculation steps
        if steps_to_run is None:
            steps_to_run = [step[0] for step in self.calculation_steps]

        # Chekc that all of the steps are valid
        # Allow the user to choose a discription name or the abbrevaition
        steps = [
            step
            for step in self.calculation_steps
            if step[0] in steps_to_run or step[1] in steps_to_run
        ]

        # The tqdm package provides a progress bar for the calculation
        with tqdm(total=len(steps), desc="SCR Calculation Progress") as pbar:
            for step_name, step_func in steps:
                pbar.set_description(f"Processing {step_name}")
                try:
                    self.create_supporting(step_func)
                    # step_func()
                except Exception as e:
                    self.handle_calculation_error(step_name, e)
                finally:
                    pbar.update(1)

    @log_decorator
    def f_diversification_calcs(self):
        """
        Calculate all the calculation combinations for diversification benefits.

        This method enables the SCR classes to be used to calculate diversification
        benefits. It retrieves the diversification level and calculation level from
        the data, and then generates combinations based on these levels.

        :raises ValueError: If the diversification level is not one of "level_1", "level_2", or "level_3".
        :raises ValueError: If the calculation level is not one of "diversification", "individual", or "overall".

        :return: None
        :rtype: None

        .. note::
            The results of the calculation are stored in `self.output["list_combinations"]`
            as a pandas DataFrame.

        .. warning::
            This method assumes that the necessary data has been loaded and is accessible
            through the `f_data` method.

        Example:
            >>> scr_instance = SCR()
            >>> scr_instance.f_diversification_calcs()
            >>> print(scr_instance.output["list_combinations"])
        """
        div_level = self.f_data("data", "data", "diversification_level").iloc[0]
        calc_level = self.f_data("data", "data", "calculation_level").iloc[0]

        valid_div_levels = ["level_1", "level_2", "level_3"]
        valid_calc_levels = ["diversification", "individual", "overall"]

        if div_level not in valid_div_levels:
            raise ValueError(
                f"Invalid diversification level: {div_level}. Must be one of {', '.join(valid_div_levels)}."
            )

        if calc_level not in valid_calc_levels:
            raise ValueError(
                f"Invalid calculation level: {calc_level}. Must be one of {', '.join(valid_calc_levels)}."
            )

        # Get all the potential divisions for the clacualtion
        divisions = self.f_data("data", "data", "division_detail")
        # Generate the combinations
        lst_combins, _ = hf.combins_df_col(divisions, div_level, calc_level)

        self.output["list_combinations"] = pd.DataFrame({"combinations": lst_combins})

    @log_decorator
    def f_aggregation(self) -> None:
        """
        Aggregate the Solvency Capital Requirement (SCR) results.

        This method performs the final aggregation step in the SCR calculation process.
        It calls a supporting function, contained in **aggregation.py**, to perform the actual aggregation and stores
        the results in the SCR object's output dictionary. The LACDT calcualtion occurs here.

        :return: None
        :rtype: None

        .. note::
            The aggregated SCR results are stored in `self.output["scr"]`.

        .. warning::
            This method assumes that all prerequisite calculations have been performed
            and that the necessary data is available for aggregation.

        Example 
        ---------
        .. code-block:: python
            >>> sam_scr = SCR()
            >>> Other import and calculations steps are not shown here ...
            >>> sam_scr.f_aggregation()
            >>> print(scr_sam_scr.output["scr"])

        Raises:
            Exception: Any exception raised during the aggregation process will be handled
                       by the `handle_calculation_error` method.
        """
        try:
            # Get the results from the supporting function
            res = agg._f_agg_scr(self)

            # Store the aggregated results
            self.output["scr"] = res

        except Exception as e:
            self.handle_calculation_error("SCR Aggregation", e)
            return

    # @log_decorator
    def f_import_data(
        self,
        risk_free_rates: str,
        symmetric_adjustment: str,
        data_file: Optional[str] = None,
        conn_string: Optional[str] = None,
        import_table: Optional[str] = None,
        export_table: Optional[str] = None,
        log_detail: Optional[str] = None,
        metadata_file: Optional[str] = None,
    ):
        """
        Import data from Excel or an ODBC connection.

        Args
        ----
            metadata_file (str): The path to the metadata file.
            risk_free_rates (str): The path to the risk-free rates file.
            symmetric_adjustment (str): The path to the symmetric adjustment file.
            data_file (str, optional): The path to the data file. Defaults to None.
            conn_string (str, optional): The ODBC connection string. Defaults to None.
            import_table (str, optional): The import table name. Defaults to None.
            export_table (str, optional): The export table name. Defaults to None.
            log_detail (str, optional): The log detail level. Defaults to None.

        Returns
        -------
            bool: True if the data import is successful.
        """

        sam_data = Data(self)

        sam_data.f_import_data(
            risk_free_rates=risk_free_rates,
            symmetric_adjustment=symmetric_adjustment,
            data_file=data_file,
            import_table=import_table,
            export_table=export_table,
            log_detail=log_detail,
            metadata_file=metadata_file,
        )
        self.classes["data"] = sam_data

        return True

    def f_validate_data(self):
        """ Validate the imported data. """
        """
        Validate the imported data against the defined schemas.

        This method checks the integrity and structure of the imported data
        using predefined schemas. It raises an exception if any validation errors are found.

        :raises pa.errors.SchemaErrors: If any validation errors occur.

        :return: None
        :rtype: None

        Example:
            >>> sam_scr = SCR()
            >>> sam_scr.f_validate_data()

        .. note::
            The validation results are stored in `self.output["data_validation"]`.
        """
        sam_data = self.classes["data"]
        sam_data.f_validate_import()


    @log_decorator
    def f_export_results(
        self, export_file: str, process_id: int = None, conn_string: str = None
    ):
        """
        Export the various results of the SCR class.

        Args:
            export_file (str): The file path to export the results to.
            process_id (int, optional): The process ID. Defaults to None.
            conn_string (str, optional): The connection string. Defaults to None.
        """
        # logger.debug("Function start")
        # Heavy lifting for this will take place in the data_checks class.
        # Aligned to the principle of keeping everything modular.

        sam_data = self.classes["data"]
        sam_data.f_export_results(export_file, process_id, conn_string)

    # @log_decorator

    @log_decorator
    def f_shapely(self) -> None:
        """
        Calculate Shapley values for diversification effects in the SCR.

        This method computes Shapley values to quantify the contribution of each
        risk component to the overall diversification benefit in the SCR calculation.
        It's only performed if the diversification level is set to "diversification".

        The Shapley values are calculated for four different SCR views:
        - Gross SCR
        - Net SCR
        - SCR with impairment
        - Gross return SCR

        :return: None

        :raises AttributeError: If required data or output structures are missing.
        :raises ValueError: If the shapely_calc function encounters invalid input.

        :example:

        >>> scr_instance = SCR()
        >>> scr_instance.f_calculate()
        >>> scr_instance.f_shapely()
        >>> print(scr_instance.output["diversification"]["gross"])

        .. note::
        The results are stored in `self.output["diversification"]` dictionary,
        with keys 'gross', 'net', 'impairment', and 'gross_return'.

        """
        # Can only perform the calculation if we have the right calc
        if (
            self.f_data("data", "data", "diversification_level").iloc[0]
            == "diversification"
        ):
            for calc in ["gross", "net", "impairment", "gross_return"]:
                scr = self.f_data("scr", "scr", calc)
                self.output["diversification"][calc] = shapely_calc(scr)

    @log_decorator
    def f_save_pickle(self, location: str = "") -> None:
        """
        Save the current SCR instance to a pickle file.

        This method serializes the entire SCR object, including all its attributes and
        calculated results, to a pickle file. The file is saved with a timestamp in its name
        for easy identification.

        :param location: Optional directory path where the pickle file should be saved.
                        If not provided, the method uses a default location based on the
                        input data file's directory.
        :type location: str

        :return: None

        :raises IOError: If there's an error writing the file.
        :raises AttributeError: If required data attributes are missing.

        :example:

        >>> scr_instance = SCR()
        >>> scr_instance.f_calculate()
        >>> scr_instance.f_save_pickle()
        Results saved to /path/to/output/results_20230615_120101.p

        .. note::
        The saved pickle file can be later loaded using the `load_pickle` class method.

        .. warning::
        Pickle files can pose a security risk if loaded from untrusted sources.
        Ensure you only load pickle files that you have created.
        """
        output_folder = self.f_data("data", "data", "file").at["data", "file"]
        output_folder = os.path.dirname(output_folder)
        current_time = datetime.datetime.now()
        timestamp = current_time.strftime("%Y%m%d_%H%M%S")
        output_filename = f"{output_folder}/results_{timestamp}.p"

        with open(output_filename, "wb") as f:
            pickle.dump(self, f)

        print(f"Results saved to {output_filename}")

    @classmethod
    def load_pickle(cls, filename):
        """
        Load SCR results from a pickle file.

        This class method deserializes a previously saved SCR object from a pickle file.
        It allows for easy restoration of SCR calculations and results.

        :param filename: The path to the pickle file containing the saved SCR object.
        :type filename: str

        :return: An instance of the SCR class with all its attributes and data.
        :rtype: SCR

        :raises FileNotFoundError: If the specified file does not exist.
        :raises pickle.UnpicklingError: If the file is not a valid pickle file or cannot be unpickled.

        :example:

        >>> scr = SCR.load_pickle("scr_results_20230615.pkl")
        >>> print(scr.output["scr"]["gross"])

        .. note::
        Ensure that the pickle file was created with a compatible version of the SCR class.
        Loading pickles from untrusted sources can be a security risk.

        .. warning::
        This method will fail if the class structure has changed significantly since the pickle was created.
        """
        with open(filename, "rb") as f:
            return pickle.load(f)

    def f_create_venv(self, location: Optional[str] = None) -> None:
        """
        Create a virtual environment for the Samplicity package.

        This method creates a new virtual environment, activates it, and installs
        the Samplicity package along with its dependencies.

        :param location: The directory where the virtual environment should be created.
                         If not provided, a default location will be used.
        :type location: str, optional
        :raises OSError: If there's an error creating the directory or the virtual environment.
        :raises subprocess.CalledProcessError: If there's an error running pip or activating the environment.

        .. note::
            If no location is provided, the virtual environment will be created in
            the user's home directory under a folder named 'samplicity_venv'.

        .. warning::
            This method requires internet access to install packages from PyPI and Bitbucket.
        """
        try:
            # Set default location if not provided
            if location is None:
                location = os.path.join(os.path.expanduser("~"), "samplicity_venv")

            # Ensure the directory exists
            os.makedirs(location, exist_ok=True)

            print(f"Creating virtual environment in: {location}")

            # Create the virtual environment
            venv.create(location, with_pip=True)

            # Determine the path to the activation script and pip
            if sys.platform == "win32":
                activate_script = os.path.join(location, "Scripts", "activate.bat")
                pip_path = os.path.join(location, "Scripts", "pip")
            else:
                activate_script = os.path.join(location, "bin", "activate")
                pip_path = os.path.join(location, "bin", "pip")

            # Activate the virtual environment and install Samplicity
            if sys.platform == "win32":
                command = f'"{activate_script}" && "{pip_path}" install git+https://bitbucket.org/omi-it/samplicity.git'
                subprocess.run(command, shell=True, check=True)
            else:
                command = f'source "{activate_script}" && "{pip_path}" install git+https://bitbucket.org/omi-it/samplicity.git'
                subprocess.run(["bash", "-c", command], check=True)

            print(
                f"Virtual environment created and Samplicity installed successfully in {location}"
            )
            print(f"To activate the environment, use: source {activate_script}")

        except OSError as e:
            print(f"Error creating directory or virtual environment: {e}")
            raise

        except subprocess.CalledProcessError as e:
            print(f"Error running pip or activating environment: {e}")
            raise

        except Exception as e:
            print(f"An unexpected error occurred: {e}")
            raise

    def f_info(self) -> pd.DataFrame:
        """
        Retrieve information about hwat information is availabel within the SCR class - and all the supporting classes.

        A DataFrame is generated showing all the information that can be returned with an indictation of the amount of data.

        :return: A DataFrame containing information about the SCR object.
        :rtype: pandas.DataFrame

        :raises TypeError: If the `info` function doesn't return a pandas DataFrame.

        Example:
            >>> sam_scr = SCR()
            >>> info_df = sam_scr.f_info()
            >>> print(info_df)

        """
        df = info.info(self)

        if not isinstance(df, pd.DataFrame):
            raise TypeError(f"Expected pandas DataFrame, got {type(df)}")

        return df

    def f_data(
        self, module: str, data: str, sub_data: str = ""
    ) -> Union[pd.DataFrame, None]:
        """
        Retrieve data from the SCR (and supporting) classes.

        This method provides a unified interface to access various data components
        within the SCR object and its supporting classes.

        :param module: The module name to retrieve data from.
        :type module: str
        :param data: The specific data name to retrieve.
        :type data: str
        :param sub_data: The sub-data name, if applicable.
        :type sub_data: str, optional
        :return: The retrieved data as a pandas DataFrame or None if not found.
        :rtype: Union[pd.DataFrame, None]
        :raises ValueError: If the requested data cannot be found or accessed.

        .. note::
            All input strings are converted to lowercase and stripped of leading/trailing spaces
            to improve user experience and reduce errors due to case sensitivity or whitespace.

        .. warning::
            This method uses a complex series of conditional statements to handle various
            data retrieval scenarios. Careful consideration should be given when modifying
            or extending this method to ensure all cases are properly handled.
        """
        try:
            # Normalize input strings
            module = module.lower().strip()
            data = data.lower().strip()
            sub_data = sub_data.lower().strip() if sub_data is not None else ""

            # Define valid modules and data types
            valid_modules = {"info", "scr", "data", "pa_data", "metadata"} | set(
                self.classes.keys()
            )
            valid_scr_data = {"list_combinations", "scr"}
            valid_scr_sub_data = {"gross", "net", "impairment", "gross_return"}

            # Check for valid module
            if module not in valid_modules:
                raise ValueError(f"Invalid module: {module}")

            # Handle different module cases
            if module == "info":
                return info(self)
            elif module == "scr":
                return self._handle_scr_data(
                    data, sub_data, valid_scr_data, valid_scr_sub_data
                )
            elif module in ("data", "pa_data", "metadata"):
                return self._handle_data_module(module, data, sub_data)
            else:
                return self.classes[module].f_data(data, sub_data)

        except Exception as e:
            # logger.critical(
            #     f"Error in f_data: {module} - {data} - {sub_data}", exc_info=True
            # )
            raise ValueError(
                f"Cannot find or access data: {module} - {data} - {sub_data}"
            ) from e

    def _handle_scr_data(
        self, data: str, sub_data: str, valid_data: set, valid_sub_data: set
    ) -> pd.DataFrame:
        """Helper method to handle 'scr' module data retrieval."""
        if data not in valid_data:
            raise ValueError(f"Invalid SCR data type: {data}")
        if data == "list_combinations":
            return self.output[data].copy(deep=True)
        if data == "scr" and sub_data in valid_sub_data:
            return self.output[data][sub_data].copy(deep=True)
        raise ValueError(f"Invalid SCR sub-data type: {sub_data}")

    def _handle_data_module(
        self, module: str, data: str, sub_data: str
    ) -> pd.DataFrame:
        """Helper method to handle 'data', 'pa_data', and 'metadata' module data retrieval."""
        try:
            if module in ("data", "pa_data", "metadata") and data not in (
                "data",
                "pa_data",
                "metadata",
            ):
                return self.classes["data"].f_data(module, data)[sub_data]
            else:
                return self.classes[module].f_data(data, sub_data)
        except KeyError:
            raise ValueError(f"Cannot find data: {module} - {data} - {sub_data}")

    def f_error_count(self, exclude_warning=True) -> int:
        """
        Count the number of errors and warnings in the output.

        This method counts the number of errors and warnings stored in the `output_errors` list.
        It provides a quick summary of the issues encountered during the SCR calculation.

        :return: The total number of errors and warnings.
        :rtype: int

        :example:

        >>> sam_scr = SCR()
        >>> sam_scr.f_calculate()
        >>> error_count = sam_scr.f_error_count()
        >>> print(f"Total errors and warnings: {error_count}")

        """
        if exclude_warning:
            return len(
                [error for error in self.output_errors if error["type"] == "error"]
            )
        else:
            return len(self.output_errors)
